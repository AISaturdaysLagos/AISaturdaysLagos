<!DOCTYPE html>
<html lang="en">
  <!-- Beautiful Jekyll | MIT license | Copyright Dean Attali 2016 -->
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="theme-color" content="#157878" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <title>Data Collection</title>

    <meta name="author" content="Practical Data Science" />
    

    <link rel="alternate" type="application/rss+xml" title="Practical Data Science - CMU 15-388/688 Spring 2019" href="/feed.xml" />
  
    
      
        <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.0/css/font-awesome.min.css" />
      
    
  
    
      
        <link rel="stylesheet" href="/css/bootstrap.min.css" />
      
        <link rel="stylesheet" href="/css/bootstrap-social.css" />
      
        <link rel="stylesheet" href="/css/main.css" />
      
    
  
    
      
        <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Lora:400,700,400italic,700italic" />
      
        <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Raleway::400,700,300" />
      
        <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" />
      
    
  
    
  
    
  
    
  
      <!-- Facebook OpenGraph tags -->
    
  
    
    <meta property="og:title" content="Data Collection" />
    
  
     
    <meta property="og:description" content="# Data Collection The first step of most data science pipelines, as you may imagine, is to get some data. Data that you typically use comes from many different sources. If you're lucky, someone may hand directly had you a file, such as a CSV (comma separated value) file or..." />
    

    <meta property="og:type" content="website" />

    
    <meta property="og:url" content="http://localhost:4000/notes/data_collection/" />
    <link rel="canonical" href="http://localhost:4000/notes/data_collection/" />
    

    
    
  
    <!-- Twitter summary cards -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:site" content="@" />
    <meta name="twitter:creator" content="@" />
  
    
    <meta name="twitter:title" content="Data Collection" />
    
  
    
    <meta name="twitter:description" content="# Data Collection The first step of most data science pipelines, as you may imagine, is to get some data. Data that you typically use comes from many different sources. If you're lucky, someone may hand directly had you a file, such as a CSV (comma separated value) file or..." />
    

    
  
  <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        jax: ["input/TeX", "output/HTML-CSS"],
        tex2jax: {
          inlineMath: [ ['$', '$'], ["$$", "$$"] ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        },
        "HTML-CSS": {
          linebreaks: {
            automatic: true
          },
          scale: 90,
          fonts: ["TeX"],
          mtextFontInherit: false,
          matchFontHeight: true
        },
        "TeX": {
          extensions: ["AMSmath.js", "AMSsymbols.js", "mediawiki-texvc.js"],
        }
        //,
        //displayAlign: "left",
        //displayIndent: "2em"
      });
  </script>
  <script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default" type="text/javascript"></script>
</head>


  <body>

    <nav class="navbar navbar-default navbar-fixed-top navbar-custom">
    <div class="container">
        <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#main-navbar">
            <span class="sr-only">Toggle navigation</span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
        </button>
        
            <a class="navbar-brand" href="http://localhost:4000">Practical Data Science</a>
        
        </div>

        <div class="collapse navbar-collapse" id="main-navbar">
        <ul class="nav navbar-nav navbar-right">
        
            <li><a href="/information" class="btn">Information</a></li>
        
            <li><a href="/lectures" class="btn">Lectures</a></li>
        
            <li><a href="/assignments" class="btn">Assignments</a></li>
        
            <li><a href="/calendar" class="btn">Calendar</a></li>
        
            <li><a href="/staff" class="btn">Staff</a></li>
        
            <li><a href="/policies" class="btn">Policies</a></li>
        
            <li><a href="/faq" class="btn">FAQ</a></li>
        
        </ul>
        </div>

        
    </div>
</nav>


    <div class="intro-header"></div>

<div role="main" class="container">
  <style type="text/css">
.targz-btn {
    float: right;
    border: thin solid #999;
    padding: 0.75rem 1rem;
    border-radius: 0.3rem;
}
</style>


<a href="data_collection.tar.gz" class="targz-btn">&#x2b73; Download Jupyter Notebook</a>

<h1 id="data-collection">Data Collection</h1>

<p>The first step of most data science pipelines, as you may imagine, is to get some data.  Data that you typically use comes from many different sources.  If you’re lucky, someone may hand directly had you a file, such as a CSV (comma separated value) file or something similar, which they want you to analyze directly.  Or sometimes you’ll need to issue a database query to collect the relevant data (we’ll discuss relational databases in a later lecture).  But in this lecture, we’ll talk about collecting data from two main sources: 1) querying an API (the majority of which are web-based, these days); and 2) scraping data from a web page.  The latter case is a common method to extract data in and of itself, but it also serves as a general example for parsing data from (relatively) <em>unstructured</em> sources.  Data that you get “in the wild” typically needs substantial preprocessing before you actually use it for data science tasks (this applies even to seemingly structured data sources like CSV files or API results), and some of the techniques we will cover in this lecture apply equally well to processing any sort of unstructured data.</p>

<h2 id="collecting-data-from-web-based-sources">Collecting data from web-based sources</h2>

<p>With those general caveats in mind, let’s dive a bit more deeply into the specific case of gather data from an web-based source, which is one of the more common forms of querying data.  It will also serve as an introduction to the type of Python coding that you’ll do in this class.</p>

<p>The first step of collecting web-based data is to issue a request for this data via some protocol: HTTP (HyperText Transfer Protocol) or HTTPS (the secure version).  And while I know that one of the principles of this course is to teach you how things work “under the hood” as well the common tools for doing so, we won’t be concerned at all with the actual HTTP protocol or how these methods work in any detail; for our purposes, we’re going to use the <a href="http://docs.python-requests.org/en/master/">requests</a> library in Python.</p>

<p>Let’s see how this works with some code.  The following code will load data from the course webpage:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">requests</span>
<span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">"http://www.cmu.edu"</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="s">"Status Code:"</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">"Headers:"</span><span class="p">,</span> <span class="n">response</span><span class="o">.</span><span class="n">headers</span><span class="p">)</span>
</code></pre></div></div>

<pre>
Status Code: 200
Headers: {&#x27;Date&#x27;: &#x27;Mon, 22 Jan 2018 02:39:55 GMT&#x27;, &#x27;Server&#x27;: &#x27;Apache&#x27;, &#x27;x-xss-protection&#x27;: &#x27;1; mode=block&#x27;, &#x27;x-content-type-options&#x27;: &#x27;nosniff&#x27;, &#x27;x-frame-options&#x27;: &#x27;SAMEORIGIN&#x27;, &#x27;Vary&#x27;: &#x27;Referer&#x27;, &#x27;Accept-Ranges&#x27;: &#x27;bytes&#x27;, &#x27;Cache-Control&#x27;: &#x27;max-age=7200, must-revalidate&#x27;, &#x27;Expires&#x27;: &#x27;Mon, 22 Jan 2018 04:39:55 GMT&#x27;, &#x27;Keep-Alive&#x27;: &#x27;timeout=5, max=500&#x27;, &#x27;Connection&#x27;: &#x27;Keep-Alive&#x27;, &#x27;Transfer-Encoding&#x27;: &#x27;chunked&#x27;, &#x27;Content-Type&#x27;: &#x27;text/html&#x27;}

</pre>

<p>This code issues an “HTTP GET” request to load the content of the paper, and returns it in the <code class="highlighter-rouge">response</code> object.  The <code class="highlighter-rouge">status_code</code> field contains the “200” code, which indicates a successful query, and the <code class="highlighter-rouge">headers</code> field contains meta-information about the page (in this case, you could see, for instance, that despite the URL, we’re actually hosting this page on github).  If you want to see the actual content of the page, you can use the <code class="highlighter-rouge">response.content</code> or <code class="highlighter-rouge">response.text</code> fields, as below.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">text</span><span class="p">[:</span><span class="mi">480</span><span class="p">])</span>
</code></pre></div></div>

<p><strong>Important note:</strong> There’s one very important point here, which may be obvious to you if you’ve spend substantial time doing any kind of software development, but if most of your experience with programming is via class exercises, it may not be completely apparent, so I emphasize it here.  You will see code samples like this throughout the course, in the slides and in these notes. It’s important <em>not</em> to take this to mean that you should memorize these precise function calls, or even do anything other than just scan over them briefly.  As a data scientist, you’ll be dealing with hundreds of different libraries and APIs, and trying to commit them all to memory is not useful.  Instead, what you need to develop is <em>the ability to quickly find a library and function call that you need to accomplish some task</em>.  For example, even if you know nothing about the in this case, you want to download the content of some URL.  You can type into Google something like <a href="https://www.google.com/search?q=python+download+url+content">“Python download url content”</a> (I just picked this precise phrasing randomly, feel free to try some variants on this).  The first result for my search is a Stack Overflow page: <a href="https://stackoverflow.com/questions/22676/how-do-i-download-a-file-over-http-using-python">How do I download a file over HTTP using Python?</a>.  While the first response actually lists the <code class="highlighter-rouge">urllib2</code> package (this was the more common library at one point, but the <code class="highlighter-rouge">requests</code> library provides a simpler interface that does things like automatically encode parameters to urls and other niceties), the <code class="highlighter-rouge">requests</code> library <a href="http://docs.python-requests.org/en/master/">home page</a> is a few responses down.  And once you find the home page for that library, the very first example on the page shows how to use it for simple calls like the one above.  You can look through documentation here, but like above, if you have a question about the <code class="highlighter-rouge">requests</code> library, you can likely use good for a direct answer there too.  For instance, if you want to learn to use the POST command, you can Google something like “python requests library post command” and the searches will either bring you straight to the relevant requests documentation or to a Stack Overflow page.</p>

<p>With all that in mind, let’s look at a few more calls we can issue with the library.  You probably have seen URLS like this before</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>https://www.google.com/search?q=python+download+url+content&amp;source=chrome
</code></pre></div></div>

<p>The <code class="highlighter-rouge">https://www.google.com/search</code> string is the URL, and everything after the ? are <em>parameters</em>; each parameter is of the form “parameter=value” and are separated by ampersands &amp;.  If you’ve seen URLS before you’ve noticed that a lot of content needs to be encoded in these parameters, such as spaces replaces with the code “%20” (the Google url above can also handle the “+” character, but “%20” is the actual encoding of a space).  Fortunately, <code class="highlighter-rouge">requests</code> handles all of this for you.  You can simply pass all the parameters as a Python dictionary.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="s">"query"</span><span class="p">:</span> <span class="s">"python download url content"</span><span class="p">,</span> <span class="s">"source"</span><span class="p">:</span><span class="s">"chrome"</span><span class="p">}</span>
<span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">"http://www.google.com/search"</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="n">params</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</code></pre></div></div>

<pre>
200

</pre>

<p>Besides the HTTP GET command, there are other common HTTP commands (POST, PUT, DELETE) which can also be called by the corresponding function in the library.</p>

<h3 id="restful-apis">RESTful APIs</h3>

<p>While parsing data in HTML (the format returned by these web queries) is sometimes a necessity, and we’ll discuss it further before, HTML is meant as a format for displaying pages visually, not as the most efficient manner for encoding data.  Fortunately, a fair number of web-based data services you will use in practice employ something called REST (Representational State Transfer, but no one uses this term) APIs.  We won’t go into detail about REST APIs, but there are a few main feature that are important for our purposes:</p>

<ol>
  <li>You call REST APIs using standard HTTP commands: GET, POST, DELETE, PUT.  You will probably see GET and POST used most frequently.</li>
  <li>REST servers don’t store state.  This means that each time you issue a request, you need to include all relevant information like your account key, etc.</li>
  <li>REST calls will usually return information in a nice format, typically JSON (more on this later).  The <code class="highlighter-rouge">requests</code> library will automatically parse it to return a Python dictionary with the relevant data.</li>
</ol>

<p>Let’s see how to issue a REST request using the same method as before.  We’ll here query my GitHub account to get information.  More info about GitHub’s REST API is available at their <a href="https://developer.github.com/v3/">Developer Site</a>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># Get your own at https://github.com/settings/tokens/new</span>
<span class="n">token</span> <span class="o">=</span> <span class="s">"3125e4430a58c5259a14ddd48157061cdb7055c0"</span> 
<span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">"https://api.github.com/user"</span><span class="p">,</span> <span class="n">params</span><span class="o">=</span><span class="p">{</span><span class="s">"access_token"</span><span class="p">:</span><span class="n">token</span><span class="p">})</span>

<span class="k">print</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">headers</span><span class="p">[</span><span class="s">"Content-Type"</span><span class="p">])</span>
<span class="k">print</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">json</span><span class="p">()</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
</code></pre></div></div>

<pre>
200
application/json; charset=utf-8
dict_keys([&#x27;login&#x27;, &#x27;id&#x27;, &#x27;avatar_url&#x27;, &#x27;gravatar_id&#x27;, &#x27;url&#x27;, &#x27;html_url&#x27;, &#x27;followers_url&#x27;, &#x27;following_url&#x27;, &#x27;gists_url&#x27;, &#x27;starred_url&#x27;, &#x27;subscriptions_url&#x27;, &#x27;organizations_url&#x27;, &#x27;repos_url&#x27;, &#x27;events_url&#x27;, &#x27;received_events_url&#x27;, &#x27;type&#x27;, &#x27;site_admin&#x27;, &#x27;name&#x27;, &#x27;company&#x27;, &#x27;blog&#x27;, &#x27;location&#x27;, &#x27;email&#x27;, &#x27;hireable&#x27;, &#x27;bio&#x27;, &#x27;public_repos&#x27;, &#x27;public_gists&#x27;, &#x27;followers&#x27;, &#x27;following&#x27;, &#x27;created_at&#x27;, &#x27;updated_at&#x27;, &#x27;private_gists&#x27;, &#x27;total_private_repos&#x27;, &#x27;owned_private_repos&#x27;, &#x27;disk_usage&#x27;, &#x27;collaborators&#x27;, &#x27;two_factor_authentication&#x27;, &#x27;plan&#x27;])

</pre>

<p>The token element there (that is an example that was linked to my account, which I have since deleted, you can get your own token for your account at <code class="highlighter-rouge">https://github.com/settings/tokens/new</code>) identifies your account, and because this is a REST API there is no “login” procedure, you just simply include this token with each call to identify yourself.  The call here is just a standard HTTP request: it requests the URL <code class="highlighter-rouge">https://api.github.com/user</code> passing our token as the parameter <code class="highlighter-rouge">access_token</code>.  The response looks similar to our above response, except if we look closer we see that the “Content-Type” in the HTTP header is “application/json”.  In these cases, the <code class="highlighter-rouge">requests</code> library has a nice function, <code class="highlighter-rouge">response.json()</code>, which will convert the returned data into a Python dictionary (I’m just showing the keys of the dictionary here).</p>

<h3 id="authentication">Authentication</h3>

<p>Most APIs will use an authentication procedure that is more involved than this example above.  The standard here for a while was called “Basic Authentication”, and can be used via the <code class="highlighter-rouge">requests</code> library by simply passing the login and password as the <code class="highlighter-rouge">auth</code> argument to the relevant calls, as below.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">"https://api.github.com/user"</span><span class="p">,</span> <span class="n">auth</span><span class="o">=</span><span class="p">(</span><span class="s">"zkolter"</span><span class="p">,</span> <span class="s">"github_password"</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">status_code</span><span class="p">)</span>
</code></pre></div></div>

<pre>
200

</pre>

<p>As seen above, GitHub does support Basic Authentication, though it’s becoming less common in a majority of APIs.  Instead, most APIs use something called OAuth, which you’ll use a little bit in the first homework.</p>

<h2 id="common-data-formats-and-handling">Common data formats and handling</h2>

<p>Now that you’ve obtained some data (either by requesting it from a web source, or just getting a file sent to you), you’ll need to know how to handle that data format.  Obviously, data comes in many different formats, but some of the more common ones that you’ll deal with as a data scientist are:</p>

<ul>
  <li>CSV (comma separated value) files</li>
  <li>JSON (Javascript object notation) files and string</li>
  <li>HTML/XML (hypertext markup language / extensible markup language) files and string</li>
</ul>

<h3 id="csv-files">CSV files</h3>

<p>The “CSV” name is really a misnomer: CSV doesn’t only refer to comma separated values, but really refers to any delimited text file (for instance, fields could be delimited by spaces or tabs, or any other character, specific to the file).  For example, let’s take a look at the following data file describing weather data near at Pittsburg airport:</p>

<p>It can be surprisingly hard to find historical weather data in CSV format (most large weather sites charge for API access, and the official National Weather Service historical data is in a custom, hard-to-parse format).  So as a shameless plug I’ll note that I downloaded this data from <a href="http://wefacts.org">http://wefacts.org</a> which is a site created by <a href="https://shawxiaozhang.github.io">Xiao Zhang</a>, a former PhD student of mine, that gives an easy interface for querying relatively large amounts of historical data in CSV form.  Description of the meaning of each data column above is <a href="https://shawxiaozhang.github.io/wefacts/">here</a>, but the important points are that the first two columns are time (UTC and local), and for example the third column is degrees Celsius scaled by 10.</p>

<p>To parse CSV files in Python, the most common library to use is <a href="https://pandas.pydata.org/">Pandas</a>, which we will cover a lot more later in this course.  For the purposes of this lecture, though, we’ll just note that we can load the data using the following code:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="n">pd</span>
<span class="n">dataframe</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="s">"kpit_weather.csv"</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s">","</span><span class="p">,</span> <span class="n">quotechar</span><span class="o">=</span><span class="s">'"'</span><span class="p">)</span>
<span class="n">dataframe</span><span class="o">.</span><span class="n">head</span><span class="p">()</span>
</code></pre></div></div>

<div><small><div>
<style>
    .dataframe thead tr:only-child th {
        text-align: right;
    }

    .dataframe thead th {
        text-align: left;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>ZTime</th>
      <th>Time</th>
      <th>OAT</th>
      <th>DT</th>
      <th>SLP</th>
      <th>WD</th>
      <th>WS</th>
      <th>SKY</th>
      <th>PPT</th>
      <th>PPT6</th>
      <th>Plsr.Event</th>
      <th>Plsr.Source</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>20170820040000</td>
      <td>20170820000000</td>
      <td>178</td>
      <td>172</td>
      <td>10171</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>-9999</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>1</th>
      <td>20170820050000</td>
      <td>20170820010000</td>
      <td>178</td>
      <td>172</td>
      <td>10177</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>-9999</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>20170820060000</td>
      <td>20170820020000</td>
      <td>167</td>
      <td>161</td>
      <td>10181</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
      <td>-9999</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>20170820070000</td>
      <td>20170820030000</td>
      <td>161</td>
      <td>161</td>
      <td>10182</td>
      <td>0</td>
      <td>0</td>
      <td>4</td>
      <td>0</td>
      <td>-9999</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>4</th>
      <td>20170820080000</td>
      <td>20170820040000</td>
      <td>156</td>
      <td>156</td>
      <td>10186</td>
      <td>180</td>
      <td>15</td>
      <td>-9999</td>
      <td>0</td>
      <td>-9999</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div></small></div>

<p>We don’t actually need the <code class="highlighter-rouge">delimiter</code> or <code class="highlighter-rouge">quotechar</code> arguments here, because the default argument for delimiter is indeed a comma (which is what this CSV file is using), but you can pass an additional argument to this function to use a different delimiter.  One issue that can come up is if any of the values you want to include contain this delimiter; to get around this, you can surround the value with the <code class="highlighter-rouge">quotechar</code> character.  Several CSV files will just include quotes around any entry, by default.  Again, our file here doesn’t contain quotes, so it is not an issue, but its it a common occurrence when handling CSV files.  One final thing to note is that by default, the first row of the file a header row that lists the name of each column in the file.  If this is not in the file, then you can load the data with the additional <code class="highlighter-rouge">header=None</code> argument.</p>

<h3 id="json-data">JSON data</h3>

<p>Although originally built as a data format specific to the Javascript language, JSON (Javascript Object Notation) is another extremely common way to share data.  We’ve already seen in it with the GitHub API example above, but very briefly, JSON allows for storing a few different data types:</p>

<ul>
  <li>Numbers: e.g. <code class="highlighter-rouge">1.0</code>, either integers or floating point, but typically always parsed as floating point</li>
  <li>Booleans: <code class="highlighter-rouge">true</code> or <code class="highlighter-rouge">false</code> (or <code class="highlighter-rouge">null</code>)</li>
  <li>Strings: <code class="highlighter-rouge">"string"</code> characters enclosed in double quotes (the <code class="highlighter-rouge">"</code> character then needs to be escaped as <code class="highlighter-rouge">\"</code>)</li>
  <li>Arrays (lists): <code class="highlighter-rouge">[item1, item2, item3]</code> list of items, where item is any of the described data types</li>
  <li>Objects (dictionaries): <code class="highlighter-rouge">{"key1":item1, "key2":item2}</code>, where the keys are strings and item is again any data type</li>
</ul>

<p>Note that lists and dictionaries can be nested within each other, so that, for instance</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>{"key1":[1.0, 2.0, {"key2":"test"}], "key3":false}
</code></pre></div></div>

<p>would be a valid JSON object.</p>

<p>Let’s look at the full JSON returned by the GitHub API above:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">content</span><span class="p">)</span>
</code></pre></div></div>

<pre>
b&#x27;{&quot;login&quot;:&quot;zkolter&quot;,&quot;id&quot;:2465474,&quot;avatar_url&quot;:&quot;https://avatars1.githubusercontent.com/u/2465474?v=4&quot;,&quot;gravatar_id&quot;:&quot;&quot;,&quot;url&quot;:&quot;https://api.github.com/users/zkolter&quot;,&quot;html_url&quot;:&quot;https://github.com/zkolter&quot;,&quot;followers_url&quot;:&quot;https://api.github.com/users/zkolter/followers&quot;,&quot;following_url&quot;:&quot;https://api.github.com/users/zkolter/following{/other_user}&quot;,&quot;gists_url&quot;:&quot;https://api.github.com/users/zkolter/gists{/gist_id}&quot;,&quot;starred_url&quot;:&quot;https://api.github.com/users/zkolter/starred{/owner}{/repo}&quot;,&quot;subscriptions_url&quot;:&quot;https://api.github.com/users/zkolter/subscriptions&quot;,&quot;organizations_url&quot;:&quot;https://api.github.com/users/zkolter/orgs&quot;,&quot;repos_url&quot;:&quot;https://api.github.com/users/zkolter/repos&quot;,&quot;events_url&quot;:&quot;https://api.github.com/users/zkolter/events{/privacy}&quot;,&quot;received_events_url&quot;:&quot;https://api.github.com/users/zkolter/received_events&quot;,&quot;type&quot;:&quot;User&quot;,&quot;site_admin&quot;:false,&quot;name&quot;:&quot;Zico Kolter&quot;,&quot;company&quot;:&quot;Carnegie Mellon&quot;,&quot;blog&quot;:&quot;&quot;,&quot;location&quot;:null,&quot;email&quot;:&quot;zkolter@cs.cmu.edu&quot;,&quot;hireable&quot;:null,&quot;bio&quot;:null,&quot;public_repos&quot;:1,&quot;public_gists&quot;:0,&quot;followers&quot;:5,&quot;following&quot;:0,&quot;created_at&quot;:&quot;2012-10-01T17:22:55Z&quot;,&quot;updated_at&quot;:&quot;2017-12-12T16:06:58Z&quot;,&quot;private_gists&quot;:0,&quot;total_private_repos&quot;:0,&quot;owned_private_repos&quot;:0,&quot;disk_usage&quot;:0,&quot;collaborators&quot;:0,&quot;two_factor_authentication&quot;:false,&quot;plan&quot;:{&quot;name&quot;:&quot;developer&quot;,&quot;space&quot;:976562499,&quot;collaborators&quot;:0,&quot;private_repos&quot;:9999}}&#x27;

</pre>

<p>We have already seen that we can use the <code class="highlighter-rouge">response.json()</code> call to convert this to a Python dictionary, but more common is to use the <code class="highlighter-rouge">json</code> library in the Python standard library: documentation page <a href="https://docs.python.org/3/library/json.html">here</a>.  To convert our GitHub response to a Python dictionary manually, we can use the <code class="highlighter-rouge">json.loads()</code> (load string) function like the following.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">json</span>
<span class="k">print</span><span class="p">(</span><span class="n">json</span><span class="o">.</span><span class="n">loads</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">content</span><span class="p">))</span>
</code></pre></div></div>

<pre>
{&#x27;login&#x27;: &#x27;zkolter&#x27;, &#x27;id&#x27;: 2465474, &#x27;avatar_url&#x27;: &#x27;https://avatars1.githubusercontent.com/u/2465474?v=4&#x27;, &#x27;gravatar_id&#x27;: &#x27;&#x27;, &#x27;url&#x27;: &#x27;https://api.github.com/users/zkolter&#x27;, &#x27;html_url&#x27;: &#x27;https://github.com/zkolter&#x27;, &#x27;followers_url&#x27;: &#x27;https://api.github.com/users/zkolter/followers&#x27;, &#x27;following_url&#x27;: &#x27;https://api.github.com/users/zkolter/following{/other_user}&#x27;, &#x27;gists_url&#x27;: &#x27;https://api.github.com/users/zkolter/gists{/gist_id}&#x27;, &#x27;starred_url&#x27;: &#x27;https://api.github.com/users/zkolter/starred{/owner}{/repo}&#x27;, &#x27;subscriptions_url&#x27;: &#x27;https://api.github.com/users/zkolter/subscriptions&#x27;, &#x27;organizations_url&#x27;: &#x27;https://api.github.com/users/zkolter/orgs&#x27;, &#x27;repos_url&#x27;: &#x27;https://api.github.com/users/zkolter/repos&#x27;, &#x27;events_url&#x27;: &#x27;https://api.github.com/users/zkolter/events{/privacy}&#x27;, &#x27;received_events_url&#x27;: &#x27;https://api.github.com/users/zkolter/received_events&#x27;, &#x27;type&#x27;: &#x27;User&#x27;, &#x27;site_admin&#x27;: False, &#x27;name&#x27;: &#x27;Zico Kolter&#x27;, &#x27;company&#x27;: &#x27;Carnegie Mellon&#x27;, &#x27;blog&#x27;: &#x27;&#x27;, &#x27;location&#x27;: None, &#x27;email&#x27;: &#x27;zkolter@cs.cmu.edu&#x27;, &#x27;hireable&#x27;: None, &#x27;bio&#x27;: None, &#x27;public_repos&#x27;: 1, &#x27;public_gists&#x27;: 0, &#x27;followers&#x27;: 5, &#x27;following&#x27;: 0, &#x27;created_at&#x27;: &#x27;2012-10-01T17:22:55Z&#x27;, &#x27;updated_at&#x27;: &#x27;2017-12-12T16:06:58Z&#x27;, &#x27;private_gists&#x27;: 0, &#x27;total_private_repos&#x27;: 0, &#x27;owned_private_repos&#x27;: 0, &#x27;disk_usage&#x27;: 0, &#x27;collaborators&#x27;: 0, &#x27;two_factor_authentication&#x27;: False, &#x27;plan&#x27;: {&#x27;name&#x27;: &#x27;developer&#x27;, &#x27;space&#x27;: 976562499, &#x27;collaborators&#x27;: 0, &#x27;private_repos&#x27;: 9999}}

</pre>

<p>If you have the data as a file (i.e., as a file descriptor opened with the Python <code class="highlighter-rouge">open()</code> command), you can use the <code class="highlighter-rouge">json.load()</code> function instead.  To convert a Python dictionary to a JSON object, you’ll use the <code class="highlighter-rouge">json.dumps()</code> command, such as the following.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="s">"a"</span><span class="p">:[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,{</span><span class="s">"b"</span><span class="p">:</span><span class="mf">2.1</span><span class="p">}],</span> <span class="s">'c'</span><span class="p">:</span><span class="mi">4</span><span class="p">}</span>
<span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">data</span><span class="p">)</span>
</code></pre></div></div>

<p>Notice that Python code, unlike JSON, can include single quotes to denote strings, but converting it to JSON will replace it with double quotes.  Finally, if you try to dump an object that includes types not representable by JSON, it will throw an error.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">json</span><span class="o">.</span><span class="n">dumps</span><span class="p">(</span><span class="n">response</span><span class="p">)</span>
</code></pre></div></div>

<pre>
TypeError: Object of type &#x27;Response&#x27; is not JSON serializable

</pre>

<h3 id="xmlhtml">XML/HTML</h3>

<p>Last, another format you will likely encoder are XML/HTML documents, though my assessment XML seems to be loosing out to JSON as a generic format for APIs and data files, at least for cases where JSON will suffice, mainly because JSON is substantially easier to parse.  XML files contain hierarchical content delineated by tags, like the following:</p>

<p>XML contains “open” tags denoted by brackets, like <code class="highlighter-rouge">&lt;tag&gt;</code>, which are then closed by a corresponding “close” tag <code class="highlighter-rouge">&lt;/tag&gt;</code>.  The tags can be nested, and have optional attributes, of the form <code class="highlighter-rouge">attribute_name="attribute_value"</code>.  Finally, there are “open/close” tags that don’t have any included content (except perhaps attributes), denoted by <code class="highlighter-rouge">&lt;openclosetag/&gt;</code>.</p>

<p>HTML, the standard for describing web pages, may seem syntactically similar to XML, but it is difficult to parse properly (open tags may not have closed tags, etc).  Generally speaking, HTML was developed to display content for the web, not to organize data, so a lot of invalid structure (like the aforementioned open without close) became standard simply because people frequently did this in practice, and so the data format evolved.  In the homework (the 688 version), you will actually write a simple XML parser, to understand how such parsing works, but for the most part you will use a library.  There are many such libraries for Python, but a particularly nice one is <a href="https://www.crummy.com/software/BeautifulSoup/">BeautifulSoup</a>.  Beautiful soup was actually written for parsing HTML (it is a common tool for scraping web pages), but it works just as well for the more-structured XML format.  You will also use BeautifulSoup as a precursor to writing your own XML parser on the homework.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">from</span> <span class="nn">bs4</span> <span class="kn">import</span> <span class="n">BeautifulSoup</span>

<span class="n">root</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="s">"""
&lt;tag attribute="value"&gt;
    &lt;subtag&gt;
        Some content for the subtag
    &lt;/subtag&gt;
    &lt;openclosetag attribute="value2"/&gt;
    &lt;subtag&gt;
        Second one
    &lt;/subtag&gt;
&lt;/tag&gt;
"""</span><span class="p">,</span> <span class="s">"lxml-xml"</span><span class="p">)</span>

<span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">subtag</span><span class="p">,</span> <span class="s">"</span><span class="se">\n</span><span class="s">"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">openclosetag</span><span class="o">.</span><span class="n">attrs</span><span class="p">)</span>
</code></pre></div></div>

<pre>
&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;
&lt;tag attribute=&quot;value&quot;&gt;
&lt;subtag&gt;
        Some content for the subtag
    &lt;/subtag&gt;
&lt;openclosetag attribute=&quot;value2&quot;/&gt;
&lt;subtag&gt;
        Second one
    &lt;/subtag&gt;
&lt;/tag&gt; 

&lt;subtag&gt;
        Some content for the subtag
    &lt;/subtag&gt; 

{&#x27;attribute&#x27;: &#x27;value2&#x27;}

</pre>

<p>The <code class="highlighter-rouge">BeautifulSoup()</code> call creates the object to parse, where the second argument specifies the parser (“lxml-xml” indicates that it is actually XML data, whereas “lxml” is the more common parser for parsing HTML files).  As illustrated above, when the hierarchical layout of the data is fairly simple, here a “tag” followed by a “subtag” (by default this will return the first such tag), or an “openclosetag”, you can access the various parts of the hierarchy simply by a structure-like layout of the BeautifulSoup object.  Where this gets trickier is when there are multiple tags with the same name as the hierarchy level, as there is with the two “subtag” tags.  Above.  In this case, you can use the <code class="highlighter-rouge">find_all</code> function, which returns a list of all the subtags.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">tag</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">"subtag"</span><span class="p">))</span>
</code></pre></div></div>

<pre>
[&lt;subtag&gt;
        Some content for the subtag
    &lt;/subtag&gt;, &lt;subtag&gt;
        Second one
    &lt;/subtag&gt;]

</pre>

<p>The nice thing about the <code class="highlighter-rouge">find_all</code> function is that you can call it at previous levels in the tree, and it will recurse down the whole document.  So we could have just as easily done.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">root</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">"subtag"</span><span class="p">))</span>
</code></pre></div></div>

<pre>
[&lt;subtag&gt;
        Some content for the subtag
    &lt;/subtag&gt;, &lt;subtag&gt;
        Second one
    &lt;/subtag&gt;]

</pre>

<p>Let’s end with a slightly more complex example, that looks through the CMU homepage to get a list of upcoming events.  This isn’t perfect (the parser will keep all the whitespace from the source HTML, and so the results aren’t always pretty), but it does the job.  If we examine the source of the CMU homepage, we’ll see that the events are listed within <code class="highlighter-rouge">&lt;div class="events"&gt;</code> tags, then within <code class="highlighter-rouge">&lt;li&gt;</code> tags.  The following illustrates how we can get the text information of each event (the <code class="highlighter-rouge">.text</code> attribute returns just the text content that doesn’t occur within any tag).  Again, the details aren’t important here, but by playing around with these calls you’ll get a sense of how to extract information from web pages or from XML documents in general.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">response</span> <span class="o">=</span> <span class="n">requests</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="s">"http://www.cmu.edu"</span><span class="p">)</span>
<span class="n">root</span> <span class="o">=</span> <span class="n">BeautifulSoup</span><span class="p">(</span><span class="n">response</span><span class="o">.</span><span class="n">content</span><span class="p">,</span> <span class="s">"lxml"</span><span class="p">)</span>
<span class="k">for</span> <span class="n">div</span> <span class="ow">in</span> <span class="n">root</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">"div"</span><span class="p">,</span> <span class="n">class_</span><span class="o">=</span><span class="s">"events"</span><span class="p">):</span>
    <span class="k">for</span> <span class="n">li</span> <span class="ow">in</span> <span class="n">div</span><span class="o">.</span><span class="n">find_all</span><span class="p">(</span><span class="s">"li"</span><span class="p">):</span>
        <span class="k">print</span><span class="p">(</span><span class="n">li</span><span class="o">.</span><span class="n">text</span><span class="o">.</span><span class="n">strip</span><span class="p">())</span>
</code></pre></div></div>

<pre>
Jan 23
                                MLK Day of Service
Jan 25
                                Performance: Il Matrimonio Segreto
Jan 25
                                Crafting a Compelling 3MT Presentation
Jan 25
                                A Conversation with Damon Young: Race, Culture, and Politics in the Age of New Media
Jan 26
                                International Privacy Day
Feb 22 - Mar 3
                                Performance: The Drowsy Chaperone

</pre>

<h2 id="regular-expressions">Regular expressions</h2>

<p>The last tool we’re going to consider in these notes are regular expressions.  Regular expressions are invaluable when parsing any type of unstructured data, if you’re trying to quickly find or extract some text from a long string, and even if you’re writing a more complex parser.  In general, regular expressions let us find and match portions of text using a simple syntax (by some definition).</p>

<h3 id="finding">Finding</h3>

<p>Let’s start with the most basic example, that simply searches text for some sting.  In this case, the text we are searching is “This course will introduce the basics of data science”, and the string we are searching for is “data science”.  This is done with the following code:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kn">import</span> <span class="nn">re</span>
<span class="n">text</span> <span class="o">=</span> <span class="s">"This course will introduce the basics of data science"</span>
<span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s">r"data science"</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">())</span>
</code></pre></div></div>

<pre>
41

</pre>

<p>The important element here is the <code class="highlighter-rouge">re.search(r"data science", text)</code> call.  It searches <code class="highlighter-rouge">text</code> for the string “data science” and returns a regular expression “match” object that contains information about where this match was found: for instance, we can find the character index (in <code class="highlighter-rouge">text</code>) where the match is found, using the <code class="highlighter-rouge">match.start()</code> call.  In addition to the search call, there are two or three more regular expression matching commands you may find useful:</p>

<ul>
  <li><code class="highlighter-rouge">re.match()</code>: Match the regular expression starting at the <em>beginning</em> of the text string</li>
  <li><code class="highlighter-rouge">re.finditer()</code>: Find all matches in the text, returning a iterator over match objects</li>
  <li><code class="highlighter-rouge">re.findall()</code>: Find all matches in the text, returning a list of the matched text only (not a match object)</li>
</ul>

<p>For example, the following code would return <code class="highlighter-rouge">None</code>, since there is no match to “data science” at the beginning of the string:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">r"data science"</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">match</span><span class="p">)</span>
</code></pre></div></div>

<pre>
None

</pre>

<p>Similarly, we could use <code class="highlighter-rouge">re.finditer()</code> to list the location of all the ‘i’ characters in the string:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">for</span> <span class="n">match</span> <span class="ow">in</span> <span class="n">re</span><span class="o">.</span><span class="n">finditer</span><span class="p">(</span><span class="s">r"i"</span><span class="p">,</span> <span class="n">text</span><span class="p">):</span>
    <span class="k">print</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">start</span><span class="p">())</span>
</code></pre></div></div>

<pre>
2
13
17
34
48

</pre>

<p>On the other hand, <code class="highlighter-rouge">re.findall()</code> just returns a list of the matched strings, with no additional info such as where they occurred:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">re</span><span class="o">.</span><span class="n">findall</span><span class="p">(</span><span class="s">r"i"</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
</code></pre></div></div>

<p>This last call may not seem particularly useful, but especially when you use more complex matching expressions, this last call can still be of some use.  Finally, you can also “compile” a regular expression and then make all the same calls on this compiled object, as in the following:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">regex</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="nb">compile</span><span class="p">(</span><span class="s">r"data science"</span><span class="p">)</span>
<span class="n">regex</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="n">text</span><span class="p">)</span>
</code></pre></div></div>

<p>However, given that Python will actually compile expressions on the fly anyways, don’t expect a big speed benefit from using the above; whether to use <code class="highlighter-rouge">re.compile()</code> separately is more of a personal preference than anything else.</p>

<h3 id="matching-multiple-potential-strings">Matching multiple potential strings</h3>

<p>While using regular expressions to search for a string within a long piece of text may be a handy tools, the real power of regular expressions comes from the ability to match multiple potential strings with a single regular expression.  This is where the syntax of regular expressions gets nasty, but here are some of the more common rules:</p>

<ul>
  <li>Any character (except special characters, <code class="highlighter-rouge">".$*+?{}\[]|()</code> ), just matches itself.  I.e., the character <code class="highlighter-rouge">a</code> just matches the character <code class="highlighter-rouge">a</code>.  This is actually what we used previously, where each character in the <code class="highlighter-rouge">r"data science"</code> regular expression was just looking to match that exact character.</li>
  <li>Putting a group of characters within brackets <code class="highlighter-rouge">[abc]</code> will match any of the characters <code class="highlighter-rouge">a</code>, <code class="highlighter-rouge">b</code>, or <code class="highlighter-rouge">c</code>. You can also use ranges within these brackets, so that <code class="highlighter-rouge">[a-z]</code> matches any lower case letter.</li>
  <li>Putting a caret within the bracket matches anything <em>but</em> these characters, i.e., <code class="highlighter-rouge">[^abc]</code> matches any character <em>except</em> <code class="highlighter-rouge">a</code>, <code class="highlighter-rouge">b</code>, or <code class="highlighter-rouge">c</code>.</li>
  <li>The special character <code class="highlighter-rouge">\d</code> will match any digit, i.e. <code class="highlighter-rouge">[0-9]</code></li>
  <li>The special character <code class="highlighter-rouge">\w</code> will match any alphanumeric character plus the underscore; i.e., it is equivalent to <code class="highlighter-rouge">[a-zA-Z0-9_]</code>.</li>
  <li>The special character <code class="highlighter-rouge">\s</code> will match whitespace, any of <code class="highlighter-rouge">[ \t\n\r\f\v]</code> (a space, tab, and various newline characters).</li>
  <li>The special character <code class="highlighter-rouge">.</code> (the period) matches <em>any</em> character.  In their original versions, regular expressions were often applies line-by-line to a file, so by default <code class="highlighter-rouge">.</code> will <em>not</em> match the newline character.  If you want it to match newlines, you pass <code class="highlighter-rouge">re.DOTALL</code> to the “flags” argument of the various regular expression calls.</li>
</ul>

<p>As an example, the following regular expression will match “data science” regardless of the capitalization, and with any type of space between the two words.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s">r"[Dd]ata\s[Ss]cience"</span><span class="p">,</span> <span class="n">text</span><span class="p">))</span>
</code></pre></div></div>

<pre>
&lt;_sre.SRE_Match object; span=(41, 53), match=&#x27;data science&#x27;&gt;

</pre>

<p>Note that now the match objects also now include what was the particular text that matched the expression (which could be one of any number of possibilities now).  This is why calls like <code class="highlighter-rouge">re.findall</code> are still useful even if they only return the matched expression.</p>

<p>The second important feature of regular expressions it the ability to match multiple <em>occurences</em> of a character.  The most important rules here are:</p>

<ul>
  <li>To match <code class="highlighter-rouge">a</code> exactly once, use <code class="highlighter-rouge">a</code>.</li>
  <li>To match <code class="highlighter-rouge">a</code> zero or one times, use <code class="highlighter-rouge">a?</code>.</li>
  <li>To match <code class="highlighter-rouge">a</code> zero or more times, use <code class="highlighter-rouge">a*</code>.</li>
  <li>To match <code class="highlighter-rouge">a</code> one or more times, use <code class="highlighter-rouge">a+</code>.</li>
  <li>And finally, to match <code class="highlighter-rouge">a</code> exactly n times, use <code class="highlighter-rouge">a{n}</code>.</li>
</ul>

<p>These rules can of course be combined with the rules to match potentially very complicated expressions.  For instance, if we want to match the text “<em>something</em> science” where <em>something</em> is any alphanumeric character, and there can be any number of spaces of any kind between <em>something</em> and the word “science”, we could use the expression <code class="highlighter-rouge">r"\w+\s+science"</code>.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">"</span><span class="err">\</span><span class="s">w+</span><span class="err">\</span><span class="s">s+science"</span><span class="p">,</span> <span class="s">"data science"</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">"</span><span class="err">\</span><span class="s">w+</span><span class="err">\</span><span class="s">s+science"</span><span class="p">,</span> <span class="s">"life science"</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">"</span><span class="err">\</span><span class="s">w+</span><span class="err">\</span><span class="s">s+science"</span><span class="p">,</span> <span class="s">"0123_abcd science"</span><span class="p">))</span>
</code></pre></div></div>

<pre>
&lt;_sre.SRE_Match object; span=(0, 12), match=&#x27;data science&#x27;&gt;
&lt;_sre.SRE_Match object; span=(0, 12), match=&#x27;life science&#x27;&gt;
&lt;_sre.SRE_Match object; span=(0, 17), match=&#x27;0123_abcd science&#x27;&gt;

</pre>

<p>These kinds of matching, even with relatively simple starting points, can lead to some interesting applications:</p>

<!-- _includes/image.html -->
<div class="image-wrapper">
        
            <img src="regex_golf.png" alt="" />
        
        
            <p class="image-caption">Regex Golf, from https://xkcd.com/1313/.  Yes, this is a real thing, see e.g. https://alf.nu/RegexGolf</p>
        
    </div>

<p><strong>Aside:</strong> One thing you may notice is the <code class="highlighter-rouge">r""</code> format of the regular expressions (quotes with an ‘r’ preceding them).  You can actually use any string as a regular expression, but the <code class="highlighter-rouge">r</code> expressions are quite handy for the following reason.  In a typical Python string, backslash characters denote escaped characters, so for instance <code class="highlighter-rouge">"\\"</code> really just encodes a single backslash.  But backslashes are <em>also</em> used within regular expressions.  So if we want the regular expression <code class="highlighter-rouge">\\</code> represented as a string (that is, match a single backslash), we’d need to use the string <code class="highlighter-rouge">"\\\\"</code>.  This gets really tedious quickly.  So the <code class="highlighter-rouge">r""</code> notation just <em>ignores</em> any handling of handling of backslashes, and thus makes inputing regular expressions much simpler.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="s">"</span><span class="se">\\</span><span class="s">"</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="s">r"\\"</span><span class="p">)</span>
</code></pre></div></div>

<pre>
\
\\

</pre>

<h3 id="grouping">Grouping</h3>

<p>Beyond the ability to just match strings, regular expressions also let you easily find specific sub-elements of the matched strings.  The basic syntax is the following: if we want to “remember” different portions of the matched expression, we just surround those portions of the regular expression in parentheses.  For example, the regular expression <code class="highlighter-rouge">r"(\w+)\s([Ss]cience)"</code> would store whatever element is matched to the <code class="highlighter-rouge">\w+</code> and <code class="highlighter-rouge">[Ss]cience</code> portions in the <code class="highlighter-rouge">groups()</code> object in the returned match.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s">r"(\w+)\s([Ss]cience)"</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">groups</span><span class="p">())</span>
</code></pre></div></div>

<pre>
(&#x27;data&#x27;, &#x27;science&#x27;)

</pre>

<p>The <code class="highlighter-rouge">.group(i)</code> notation also lets you easily find just individual groups, <code class="highlighter-rouge">.group(0)</code> being the entire text.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">match</span> <span class="o">=</span> <span class="n">re</span><span class="o">.</span><span class="n">search</span><span class="p">(</span><span class="s">r"(\w+)\s([Ss]cience)"</span><span class="p">,</span> <span class="n">text</span><span class="p">)</span>
<span class="k">print</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">1</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">match</span><span class="o">.</span><span class="n">group</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span>
</code></pre></div></div>

<pre>
data science
data
science

</pre>

<h3 id="substitutions">Substitutions</h3>

<p>Regular expression can also be used to automatically substitute one expression for another within the string.  This is done using the <code class="highlighter-rouge">re.sub()</code> call.  This returns a string with (all) the instances of the first regular expression replaced with the second one.  For example, to replace all the occurrences of “data science” with “data schmience”, we could use the following code:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">r"data science"</span><span class="p">,</span> <span class="s">r"data schmience"</span><span class="p">,</span> <span class="n">text</span><span class="p">))</span>
</code></pre></div></div>

<pre>
This course will introduce the basics of data schmience

</pre>

<p>Where this gets really powerful is when we use groups in the first regular expression.  These groups can then be backreferenced using the <code class="highlighter-rouge">\1</code>, <code class="highlighter-rouge">\2</code>, etc notation in the second one (more generally, you can actually use these backreferencs within a single regular expression too, outside the context of substitutions, but we won’t cover that here).  So if we have the regular expression <code class="highlighter-rouge">r"(\w+) ([Ss])cience"</code> to match “<em>something</em> science” (where science can be capitalized or not), we would replace it with the string “<em>something</em> schmience”, keeping the <em>something</em> the same, and keeping the capitalization of science the same, using the code:</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">r"(\w+) ([Ss])cience"</span><span class="p">,</span> <span class="s">r"\1 \2chmience"</span><span class="p">,</span> <span class="n">text</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="s">r"(\w+) ([Ss])cience"</span><span class="p">,</span> <span class="s">r"\1 \2chmience"</span><span class="p">,</span> <span class="s">"Life Science"</span><span class="p">))</span>
</code></pre></div></div>

<pre>
This course will introduce the basics of data schmience
Life Schmience

</pre>

<p>As you can imagine, this allows for very powerful processing with very short expressions.  For example, to create the notes for this Data Science Course, I actually do post-processing of Jupyter Notebooks, and use regular expressions to covert (along with some other Python code) to convert various syntax to Markdown-friendly syntax for the course web page.  For tasks like this, regular expressions are an incredibly useful tool.</p>

<h3 id="miscellaneous-items">Miscellaneous items</h3>

<p>There are a few last points that we’ll discuss here, mainly because they can be of some use for the homework assignments in the course.  There are, of course, many more particulars to regular expressions, and we will later highlight a few references for further reading.</p>

<p><strong>Order of operations.</strong> The first point comes in regard to the order of operations for regular expressions.  The <code class="highlighter-rouge">|</code> character in regular expressions is like an “or” clause, the regular expression should can match the regular expression to the left or to the right of the character.  For example, the regular expression <code class="highlighter-rouge">r"abc|def"</code> would match the string “abc” or “def”.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">r"abc|def"</span><span class="p">,</span> <span class="s">"abc"</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">r"abc|def"</span><span class="p">,</span> <span class="s">"def"</span><span class="p">))</span>
</code></pre></div></div>

<pre>
&lt;_sre.SRE_Match object; span=(0, 3), match=&#x27;abc&#x27;&gt;
&lt;_sre.SRE_Match object; span=(0, 3), match=&#x27;def&#x27;&gt;

</pre>

<p>But what if we want to match the string “ab<em>(c or d)</em>ef”?  We can capture this in a regular expression by parentheses around the portion we want to give a higher order of operations.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">r"abc|def"</span><span class="p">,</span> <span class="s">"abdef"</span><span class="p">))</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">r"ab(c|d)ef"</span><span class="p">,</span> <span class="s">"abdef"</span><span class="p">))</span>
</code></pre></div></div>

<pre>
None
&lt;_sre.SRE_Match object; span=(0, 5), match=&#x27;abdef&#x27;&gt;

</pre>

<p>But, of course, since we also use the parentheses for specifying groups, this means that we will be creating a group for the <em>c or d</em> character here.  While it’s probably not the end of the world to create a few groups you don’t need, in the case that you <em>don’t</em> want to create this group, you can use the notation <code class="highlighter-rouge">r"ab(?:c|d)ef"</code>.  There is no real logic to this notation that I can see, it just happens to be shorthand for “use these parentheses to manage order of operations but don’t create a group.”  Regular expressions are full of fun things like this, and while you likely don’t need to commit this to memory, it’s handy to remember that there are situations like this.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">r"ab(c|d)ef"</span><span class="p">,</span> <span class="s">"abdef"</span><span class="p">)</span><span class="o">.</span><span class="n">groups</span><span class="p">())</span>
<span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">r"ab(?:c|d)ef"</span><span class="p">,</span> <span class="s">"abdef"</span><span class="p">)</span><span class="o">.</span><span class="n">groups</span><span class="p">())</span>
</code></pre></div></div>

<pre>
(&#x27;d&#x27;,)
()

</pre>

<p><strong>Greedy and lazy matching</strong> The second point is something that you likely <em>will</em> need to know, at least in the context of the homework.  This is the fact that, by default, regular expressions will always match <em>the longest possible string</em>.  So suppose we have the regular expression <code class="highlighter-rouge">r"&lt;.*&gt;"</code> (a less-than, followed by any number of any character, followed by a greater-than).  As you might imagine, this sort of expression will come up if (and for this class, when) you’re writing a parser for a format like XML.  If we try to match the string “&lt;tag&gt;hello&lt;/tag&gt;”, then the regular expression will match the <em>entire</em> string (since the entire string is a less-than, followed by some number of characters, followed by a greater-than); it will not just match the “&lt;tag&gt;” part of the string.  This is known as “greedy” matching.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">r"&lt;.*&gt;"</span><span class="p">,</span> <span class="s">"&lt;tag&gt;hello&lt;/tag&gt;"</span><span class="p">))</span>
</code></pre></div></div>

<pre>
&lt;_sre.SRE_Match object; span=(0, 16), match=&#x27;&lt;tag&gt;hello&lt;/tag&gt;&#x27;&gt;

</pre>

<p>In the case where you don’t want this, but would instead want you match the <em>smallest</em> possible string, you can use the alternative regular expression <code class="highlighter-rouge">r"&lt;.*?&gt;"</code>.  The <code class="highlighter-rouge">*?</code> notation indicates “lazy” matching, that you want to match any number of characters possible, but would prefer the <em>smallest</em> possible match.  This will then match just the “&lt;tag&gt;” string.</p>

<div class="language-python highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">print</span><span class="p">(</span><span class="n">re</span><span class="o">.</span><span class="n">match</span><span class="p">(</span><span class="s">r"&lt;.*?&gt;"</span><span class="p">,</span> <span class="s">"&lt;tag&gt;hello&lt;/tag&gt;"</span><span class="p">))</span>
</code></pre></div></div>

<pre>
&lt;_sre.SRE_Match object; span=(0, 5), match=&#x27;&lt;tag&gt;&#x27;&gt;

</pre>

<h3 id="final-note">Final note</h3>

<p>As one last note, while it is good to run through all of these aspects of regular expressions, they are likely something that you will not remember unless you use regular expressions quite often; the notation of regular expressions is dense and not well-suited to effortless memorization.  I had to look up a few things myself when preparing this lecture and notes.  And there are some completely crazy constructs, like the famous regular expression <code class="highlighter-rouge">r".?|(..+?)\\1+"</code> that <a href="https://iluxonchik.github.io/regular-expression-check-if-number-is-prime/">matches only prime numbers of characters</a>.</p>

<p>The point is, for anything remotely complex that you’d do with regular expression, you will have to look up the documentation, which for the Python libraries is available at: <a href="https://docs.python.org/3/howto/regex.html">https://docs.python.org/3/howto/regex.html</a> and <a href="https://docs.python.org/3/library/re.html">https://docs.python.org/3/library/re.html</a>.  These sources will be the best way to remember specifics about any particular syntax you want to use.</p>

<h2 id="references">References</h2>

<ul>
  <li><a href="http://docs.python-requests.org/en/master/">requests library</a></li>
  <li>Fielding, Roy. <a href="http://www.ics.uci.edu/~fielding/pubs/dissertation/rest_arch_style.htm">Representational State Transfer (REST)</a> (thesis chapter where REST was first proposed)</li>
  <li><a href="http://wefacts.org">WeFacts</a> (historical weather data)</li>
  <li><a href="https://pandas.pydata.org">Pandas library</a></li>
  <li><a href="https://docs.python.org/3/library/json.html">json library</a></li>
  <li><a href="https://www.crummy.com/software/BeautifulSoup/">BeautifulSoup library</a></li>
  <li><a href="https://docs.python.org/3/howto/regex.html">Python Regular Expression HOWTO</a></li>
  <li><a href="https://docs.python.org/3/library/re.html">Python regular expression library</a></li>
</ul>


</div>


    <footer>
<div class="container">
    <div class="row">
        <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">
        <h4>Contact</h4>
        <div>
            Practical Data Science
            &nbsp;&nbsp;&bull;&nbsp;&nbsp;
            <a href="mailto:gmanek@cs.cmu.edu">gmanek@cs.cmu.edu</a>
        </div>
    </div>

    <div class="col-lg-8 col-lg-offset-2 col-md-10 col-md-offset-1">       <p class="theme-by text-muted">
        Theme based on <a href="http://deanattali.com/beautiful-jekyll/">beautiful-jekyll</a>
    </p>
    </div>
    </div>
    </div>
</footer>
  
    






  
    <script src="/js/jquery-1.11.2.min.js"></script>
  
    <script src="/js/bootstrap.min.js"></script>
  
    <script src="/js/main.js"></script>
  





  
  </body>
</html>
